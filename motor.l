
/* Copyright (c) 2013 Gareth Scott */

%option noyywrap
%option yylineno
/* Remove warning, yyunput defined but not used */
%option nounput
/* Remove warning, input defined but not used */
%option noinput 

%{
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

//#include "compiler.h"
//#include "motor.tab.h"	// To see the %union in valve.y  Generated by bison with -d option

void debugPrintf(const char* pc);

YYSTYPE yylval;
%}

line			[A-Ha-h][0-7]
digit			[0-9]
float           -?{digit}+\.{digit}+
/* Using [A-Za-z0-9] will cause 'a[x]' to be lexed as an alphanum. Don't want the [ character to be interpreted as a character. */
alpha			[A-Za-z]
alphanum		[A-Za-z0-9]
period			[.]
eol             [\n]
%x		comment
%x 		commentNew

%%
"<VERS>"            {debugPrintf("VERSION_BEGIN"); return VERSION_BEGIN;}
"<vers>"            {debugPrintf("VERSION_END"); return VERSION_END;}
"<STMT>"            {debugPrintf("STATEMENT_BEGIN"); return STATEMENT_BEGIN;}
"<stmt>"            {debugPrintf("STATEMENT_END"); return STATEMENT_END;}
"<SYMB>"            {debugPrintf("SYMBOL_BEGIN"); return SYMBOL_BEGIN;}
"<symb>"            {debugPrintf("SYMBOL_END"); return SYMBOL_END;}
"ROOT"     	        {debugPrintf("ROOT"); return ROOT;}
"LEFT"     	        {debugPrintf("LEFT"); return LEFT;}
"RIGHT"             {debugPrintf("RIGHT"); return RIGHT;}
"Variable"          {debugPrintf("VARIABLE"); return VARIABLE;}
"Operator"          {debugPrintf("OPERATOR"); return OPERATOR;}
"If"                {debugPrintf("IF"); return IF;}
"EVAL0"             {debugPrintf("EVAL0"); return EVAL0;}
"EVALWHILE0"        {debugPrintf("EVALWHILE0"); return EVALWHILE0;}
"Else"              {debugPrintf("ELSE"); return ELSE;}
"EndIf"             {debugPrintf("ENDIF"); return ENDIF;}
"While"             {debugPrintf("WHILE"); return WHILE;}
"EndWhile"          {debugPrintf("ENDWHILE"); return ENDWHILE;}
"FunctionCall"      {debugPrintf("FUNCTIONCALL"); return FUNCTIONCALL;}
"FunctionCallEnd"   {debugPrintf("FUNCTIONCALLEND"); return FUNCTIONCALLEND;}
"JmpEndIf"          {debugPrintf("JMPENDIF"); return JMPENDIF;}
"Start"             {debugPrintf("START"); return START;}
"ProgramEnd"        {debugPrintf("PROGRAMEND"); return PROGRAMEND;}
-?{digit}+		    {debugPrintf("CONST"); yylval.string = strdup(yytext); return CONST;}	/* constant integer */
{eol}       {}  /* Need this to get yylineno incrementing. */

"/*"				BEGIN(comment);

<comment>[^*\n]*	/* eat anything that's not a '*' */

<comment>"*/"		BEGIN(INITIAL);

"//"				BEGIN(commentNew);

<commentNew>.		/* eat everything until '\n' */

<commentNew>[\n]	BEGIN(INITIAL);


%%
/* Start of user defined code section. */
/* If you're just trying to debug the lexical analyzer then uncomment
	the code containing 'main()' below and in the 'rules' section above
	replace the code in braces {} with something like: 'printf("line token");'.
	You won't have access to the macros LINE, OUTPUTS, etc. unless you link
	with 'port_tab.c' file outputted by bison.
*/


extern int yylex();

#if BISON_PHASE
#define ECHO_DEBUG	0
#else /* not BISON_PHASE */
#define ECHO_DEBUG	1
#endif /* BISON_PHASE */

#if !ECHO_DEBUG
// Turn off ECHO
#ifdef ECHO
#undef ECHO
#endif /* ECHO */
#define ECHO
#endif /* not ECHO_DEBUG */

void debugPrintf(const char* pc) {
// FLEX_DEBUG defined with -d command line option
#if ECHO_DEBUG
	printf("[%s]", pc);
#endif /* ECHO_DEBUG */
}

#if !BISON_PHASE
int main(int argc, char* argv[])
{
	printf("Start scanner\n"); fflush(stdout);
    yyin = fopen( "valve3x.def", "r" );
	int r = yylex();
	while (r != 0) {
		ECHO;
		//printf("%d %s\n", r, yylval.string);
		r = yylex();
	}
	printf("\n\nEnd scanner"); fflush(stdout);
	return r;
	//return yylex();
}
#endif /* BISON_PHASE */

/* End of user defined code section. */
