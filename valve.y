
/* Copyright (c) 2011, Gareth Scott */

/*
       Sample of motor control language:
	   counter == 4 && (m1.position >= 3 || m1.velocity < 0) {
			counter = counter + 1;
			m1.position = 2;
			
	   }

*/

%{
/* #define YYDEBUG 1 */
#include <stdio.h>
#include <malloc.h>
#include <string.h>
#include "compiler.h"

// Variable symbol table
varNode varTable[VAR_ITEMS];
unsigned int varTableFreeIndex = 0;

%}

/* See compiler.h for definition of 'node' */
%union {
	int number;
	char* string;
	node* pNode;	
}

/* TERMINALS */
%token INPUTS OUTPUTS LBRACE RBRACE COMMA BANG LPAREN RPAREN
%token <number> 	EQUAL PLUS MINUS MULT DIV XOR GEQ LEQ NEQ GTR LSS AND OR TEST_FOR_EQUAL SEMI
%token <string>	VAR VAR_METHOD CONST

%left PLUS MINUS
%left MULT DIV	/* last one gets highest precedence */

/* non-terminals */
/* %type <int>	*/
%type <number> identifier operator binaryPredicate operandTest
%type <string> patternAction var
%type <pNode>  pattern action statementAction arithmeticExpression patternCompare

%defines	/* generate valve.tab.h for use with lex.yy.c */

/* %left pattern */

%start program

%% /* Grammar rules and actions */
program: 	patternActionList	{return 0;}
;

patternActionList: /* empty */	{}
					| patternActionList patternAction	
;

patternAction: pattern LBRACE action RBRACE	{doPatternAction($1, $3);}
;

action: /* empty */	{}
		| action statementAction	{/*$$ = addNodeOperatorAction($1, $2);*/}
;

statementAction:	var EQUAL arithmeticExpression SEMI	{}	/* Check if var in symbol table. If not, insert. */
;			

/* eg: patternCompare && patternCompare */
pattern: 	LPAREN pattern RPAREN	{$$ = $2;}
			| patternCompare binaryPredicate pattern	{/*$$ = addNodeOperator($2, $1, $3);*/}
			| patternCompare	{}
;

/* eg:  c1 == c2 + c3 + 4;
		45
		c5
*/
patternCompare:	var operandTest arithmeticExpression	{}
				| identifier {}
;

/* eg: 	45
		c2
		c2 + (c3 * 4)
*/   
arithmeticExpression:	LPAREN arithmeticExpression RPAREN	{$$ = $2;}
						| arithmeticExpression operator arithmeticExpression	{$$ = addNodeOperator($2, $1, $3);}
						| identifier	{$$ = addNodeId($1);}
;						

identifier:	var	{$$ = addNodeVar($1);}	/* Set top of stack to index of this variable. */
			| CONST {$$ = addNodeVar($1);}
;			

var:		VAR
			| VAR_METHOD
;			

binaryPredicate:	AND
					| OR
;			

operandTest:	TEST_FOR_EQUAL
				| GEQ
				| LEQ
				| GTR
				| LSS
;

operator:	PLUS
			| MINUS
			| MULT
			| DIV
			| XOR
;			


%% /* Additional C code */


#include "lex.yy.c"

void yyerror (char* s)
{
	printf (" %s\n", s);
}

main ()
{
#if 0
	/* Initialize IO boilerplate code. */
	FILE* stream = fopen("\\dev\\parser\\port1\\boilerplate.c", "r" );
	if (stream == NULL) {
		printf("Error opening boilerplate code.\n");
	} else {
		#define BUF_LEN (256)
		char buffer[BUF_LEN];
		printf("/* This code automatically generated by ZPORT 1.0. */\n", buffer);
		while (fgets(buffer, BUF_LEN, stream) != NULL) {
			printf("%s", buffer);
		}
		fclose(stream);
	}
#endif

	// To turn on debugging, make sure the next line is uncommented and
	//  turn on the -t (also use -v -l) options in bison.exe.
	yydebug = 1; 
    yyin = fopen("valve2.def", "r" );
	yyparse ();
	// The closing braces for 'main()' and 'while (TRUE)'.
	printf("\n} /* while */");
	printf("\n} /* main */\n");
}

void initVarTable(varNode* pTable, unsigned int len) {
	--len;
	for (; len >= 0; --len) {
		pTable[len].name[0] = EOS;
		pTable[len].val = 0;	// Initialize variable to 0;
	}
}

// Return index of variable or constant in symbol table
int insertVariable(varNode* pTable, varNode* pVar) {
	if (varTableFreeIndex < VAR_ITEMS) {
		pTable[varTableFreeIndex] = *pVar;
		return varTableFreeIndex++;
	}
	return VAR_TABLE_LIMIT;
}

int getVariable(varNode* pTable, varNode* pVar) {
	int found = findVariable(pTable, pVar);
	if (found != VAR_NOT_FOUND) {
		// found it
		pVar->val = pTable[found].val;
	}
	return found;
}

int setVariable(varNode* pTable, varNode* pVar) {
	int found = findVariable(pTable, pVar);
	if (found == VAR_NOT_FOUND) {
		insertVariable(pTable, pVar);
	} else {
		// found it
		pTable[found].val = pVar->val;
	}
	return found;
}

// Return index where variable is located in varTable, or -1 on failure.
int findVariable(varNode* pTable, varNode* pVar) {
	int i;
	for (i = 0; i < varTableFreeIndex; ++i) {
		if (strncmp(pTable[i].name, pVar->name, VAR_NAME_LENGTH-1) == 0) {
			return i;
		}
	}
	return VAR_NOT_FOUND;
}

void pushInputLine(char* line) {
	printf("\nsetLineAsInput(\"%s\");", line);
}

void pushOutputLine(char* line) {
	printf("\nsetLineAsOutput(\"%s\");", line);
}

// The following 2 functions are only used by 'pattern' in the 
//  'pattern {action} part of the grammar.
node* addNodeOperator(int type, node* pLeft, node* pRight) {
	node* p = malloc(sizeof(node));
	if (p == NULL) {
		//assert(p != NULL);
		yyerror("malloc() failed in call to addNodeOperator()");
	}
	p->idValue[0] = EOS;
	if (type == AND) {
		p->operand = enumAnd;
	} else if (type == OR) {
		p->operand = enumOr;
	}
	p->pLeft = pLeft;
	p->pRight = pRight;
	return p;	
}

node* addNodeId(int varIndex) {
#if 0
	//assert(id != NULL);
	node* p = malloc(sizeof(node));
	if (p == NULL) {
		//assert(p != NULL);
		yyerror("malloc() failed in call to addNodeId()");
	}
	p->operand = enumId;
	// Remember an id can be 'a3' or '!g7'.
	p->idValue[0] = id[0];
	p->idValue[1] = id[1];
	p->idValue[2] = id[2];
	if (id[0] == '!') {
		p->idValue[3] = id[3];
	}
	p->pLeft = NULL;
	p->pRight = NULL;
	return p;	
#endif
}

node* getAvailNode(void) {
	return NULL;
}

int addNodeVar(char* var) {
	varNode tmp;
	strncpy(tmp.name, var, VAR_NAME_LENGTH-1);
	tmp.name[VAR_NAME_LENGTH-1] = EOS;
	tmp.val = 0;
	if (isdigit(var[0])) {
		// Assume it's a constant, but can just treat it like a variable, making sure that
		//  any variable that starts with a numberic (i.e. a constant) is never altered.
		tmp.val = atoi(var);
	}
	int found = findVariable(varTable, &tmp);
	if (found == VAR_NOT_FOUND) {
		return insertVariable(varTable, &tmp);
	}
	return found;
	
	#if 0
	//assert(id != NULL);
	node* pn = getAvailNode();
	if (pn == NULL) {
		//assert(p != NULL);
		yyerror("malloc() failed in call to addNodeId()");
	}
	pn->type = nodeVar;
	//pn->value = findVarInSymbolTable(var);
	pn->pLeft = NULL;
	pn->pRight = NULL;
	return pn;	
	#endif
}


// The following 2 functions are only used by 'action' in the 
//  'pattern {action} part of the grammar.
node* addNodeOperatorAction(node* pNode, char* id) {
	node* p = malloc(sizeof(node));
	if (p == NULL) {
		//assert(p != NULL);
		yyerror("malloc() failed in call to addNodeOperator()");
	}
	p->operand = enumAction;
	// Remember an id can be 'a3' or '!g7'.
	p->idValue[0] = id[0];
	p->idValue[1] = id[1];
	p->idValue[2] = id[2];
	if (id[0] == '!') {
		p->idValue[3] = id[3];
	}
	p->pLeft = NULL;
	p->pRight = pNode;
	return p;	
}

node* addNodeActionId(char* id) {
	//assert(id != NULL);
	node* p = malloc(sizeof(node));
	if (p == NULL) {
		//assert(p != NULL);
		yyerror("malloc() failed in call to addActionNodeId()");
	}
	p->operand = enumAction;
	// Remember an id can be 'a3' or '!g7'.
	p->idValue[0] = id[0];
	p->idValue[1] = id[1];
	p->idValue[2] = id[2];
	if (id[0] == '!') {
		p->idValue[3] = id[3];
	}
	p->pLeft = NULL;
	p->pRight = NULL;
	return p;	
}

void doPatternAction(node* pPattern, node* pAction)
{
	{
	/* Output statement. */
	printf("\nif ");
	// Output Pattern statements.
	walkPatternTree(pPattern, FALSE);
	printf("  {");

	// Output Action statements.
	walkActionTree(pAction, FALSE);

	printf("\n/* Latch data into LED(0). */");
	printf("\nsetOutput(\"!e7\");");
	printf("\nsetOutput(\"e7\");");
	printf("\n} /* if */\n");
	}

	{
	/* Output complement statement. */
	printf("\nif ");
	// Output Pattern statements.
	walkPatternTree(pPattern, TRUE);
	printf("  {");

	// Output Action statements.
	walkActionTree(pAction, TRUE);

	printf("\n/* Latch data into LED(0). */");
	printf("\nsetOutput(\"!e7\");");
	printf("\nsetOutput(\"e7\");");
	printf("\n} /* if */\n");
	}

	freeNode(pPattern);
	freeNode(pAction);
}

// Walk tree in infix mode; left, root right.
void walkPatternTree(node* pNode, char complement) {
	if (pNode == NULL) {
		return;
	}
	printf(" ( ");
	walkPatternTree(pNode->pLeft, complement);
	if (pNode->operand == enumId) {
		if (complement) {
			if (pNode->idValue[0] == '!') {
				// Don't want to preceed an ! with another !. Our language can't
				//  handle that so we'll just strip off the first !.
				printf(" getInput(\"%s\") ", &pNode->idValue[1]);
			} else {
				printf(" getInput(\"!%s\") ", pNode->idValue);
			}
		} else {
			printf(" getInput(\"%s\") ", pNode->idValue);
		}
	} else if (pNode->operand == enumAnd) {
		if (complement) {
			printf(" || ");
		} else {
			printf(" && ");
		}
	} else if (pNode->operand == enumOr) {
		if (complement) {
			printf(" && ");
		} else {
			printf(" || ");
		}
	} else {
		//assert(false);
	}
	walkPatternTree(pNode->pRight, complement);
	printf(" ) ");
}

void walkActionTree(node* pNode, char complement) {
	if (pNode == NULL) {
		return;
	}
	walkActionTree(pNode->pRight, complement);
	if (pNode->operand == enumAction) {
		if (complement) {
			if (pNode->idValue[0] == '!') {
				// Don't want to preceed an ! with another !. Our language can't
				//  handle that so we'll just strip off the first !.
				printf("\nsetOutput(\"%s\"); ", &pNode->idValue[1]);
			} else {
				printf("\nsetOutput(\"!%s\"); ", pNode->idValue);
			}
		} else {
			printf("\nsetOutput(\"%s\"); ", pNode->idValue);
		}
	} else {
		//assert(false);
	}
}

void freeNode(node* pNode) {
	if (pNode == NULL) {
		//assert(pNode != NULL);
		return;
	}
	if (pNode->operand != enumId) {
		// It's not an Id, it's an operand.
		//assert(pNode->pLeft != NULL);	
		//assert(pNode->pRight != NULL);	
		freeNode(pNode->pLeft);
		freeNode(pNode->pRight);
	}
	free(pNode);
}


int infixPatternTraversal(node* pn) {
	if (pn->type == nodeOperator) {
		int valueLeft = infixPatternTraversal(pn->pLeft);
		// Short-circuit evaluation
		if (pn->value == OP_OR && valueLeft != FALSE) {
			return valueLeft;
		}
		int valueRight = infixPatternTraversal(pn->pRight);
		switch (pn->value) {
		case OP_PLUS:
			return valueLeft + valueRight;
		case OP_MINUS:
			return valueLeft - valueRight;
		case OP_MULT:
			return valueLeft * valueRight;
		case OP_DIV:
			return valueLeft / valueRight;
		default:
			// Got unrecognized opcode!
			break;
		}
	}
	// It's an operand so just return its value.
	return pn->value;
}
