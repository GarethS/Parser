Nonterminals useless in grammar

   patternActionList
   patternAction
   action
   statementAction
   pattern
   patternCompare
   arithmeticExpression
   identifier
   var
   binaryPredicate
   operator


Terminals unused in grammar

   INPUTS
   OUTPUTS
   COMMA
   BANG
   EQUAL
   PLUS
   MINUS
   MULT
   DIV
   XOR
   NEQ
   AND
   OR
   SEMI
   LBRACE
   RBRACE
   LPAREN
   RPAREN
   VAR
   VAR_METHOD


Rules useless in grammar

    8 patternActionList: /* empty */
    9                  | patternActionList patternAction

   10 patternAction: pattern LBRACE action RBRACE

   11 action: /* empty */
   12       | action statementAction

   13 statementAction: var EQUAL arithmeticExpression SEMI

   14 pattern: LPAREN pattern RPAREN
   15        | pattern binaryPredicate patternCompare
   16        | patternCompare

   17 patternCompare: var operandTest arithmeticExpression
   18               | identifier

   19 arithmeticExpression: LPAREN arithmeticExpression RPAREN
   20                     | arithmeticExpression operator arithmeticExpression
   21                     | identifier

   22 identifier: var
   23           | CONST

   24 var: VAR
   25    | VAR_METHOD

   26 binaryPredicate: AND
   27                | OR

   28 operator: PLUS
   29         | MINUS
   30         | MULT
   31         | DIV
   32         | XOR


Grammar

    0 $accept: program $end

    1 program: test1

    2 test1: CONST operandTest

    3 operandTest: TEST_FOR_EQUAL
    4            | GEQ
    5            | LEQ
    6            | GTR
    7            | LSS


Terminals, with rules where they appear

$end (0) 0
error (256)
INPUTS (258)
OUTPUTS (259)
COMMA (260)
BANG (261)
EQUAL (262)
PLUS (263)
MINUS (264)
MULT (265)
DIV (266)
XOR (267)
GEQ (268) 4
LEQ (269) 5
NEQ (270)
GTR (271) 6
LSS (272) 7
AND (273)
OR (274)
TEST_FOR_EQUAL (275) 3
SEMI (276)
LBRACE (277)
RBRACE (278)
LPAREN (279)
RPAREN (280)
VAR (281)
VAR_METHOD (282)
CONST (283) 2


Nonterminals, with rules where they appear

$accept (29)
    on left: 0
program (30)
    on left: 1, on right: 0
test1 (31)
    on left: 2, on right: 1
operandTest (32)
    on left: 3 4 5 6 7, on right: 2


state 0

    0 $accept: . program $end

    CONST  shift, and go to state 1

    program  go to state 2
    test1    go to state 3


state 1

    2 test1: CONST . operandTest

    GEQ             shift, and go to state 4
    LEQ             shift, and go to state 5
    GTR             shift, and go to state 6
    LSS             shift, and go to state 7
    TEST_FOR_EQUAL  shift, and go to state 8

    operandTest  go to state 9


state 2

    0 $accept: program . $end

    $end  shift, and go to state 10


state 3

    1 program: test1 .

    $default  reduce using rule 1 (program)


state 4

    4 operandTest: GEQ .

    $default  reduce using rule 4 (operandTest)


state 5

    5 operandTest: LEQ .

    $default  reduce using rule 5 (operandTest)


state 6

    6 operandTest: GTR .

    $default  reduce using rule 6 (operandTest)


state 7

    7 operandTest: LSS .

    $default  reduce using rule 7 (operandTest)


state 8

    3 operandTest: TEST_FOR_EQUAL .

    $default  reduce using rule 3 (operandTest)


state 9

    2 test1: CONST operandTest .

    $default  reduce using rule 2 (test1)


state 10

    0 $accept: program $end .

    $default  accept
